# 0. 구구단, 끝말잇기

## 00-01. 강좌시작

lecture폴더에 typescript, react관련된것들 설치

```bash
npm i
npm i tyescript
npm i react react-dom

npm i webpack webpack-cli --save-dev
npm i ts-loader ts-node @types/webpack --save-dev
```

❗ webpack으로 최신문법과 jsx문법을 옛날 문법으로 바꿔준다.

typescript는 자체적으로 최신 문법을 es5 ~es3까지 지원이 필요해 babel이 필요없다.(무조건은 아니다.)



**loader**

webpack과 typescript의 연결.

* ts-loader : webpack과 typescript연결
* awesome-typescript-loader (atl)

awesome은 use Babel을 통해서 babel과 함께 쓸 수 있다. (강좌의 경우 typescript version 4와 awesomeloader와 문제가 있어 ts-loader를 설치.)



react나 react-dom처럼 타입이 없는 경우 definitely typd community에서 찾아서 설치.

대신 버전확인에 주의를 기울여야한다.



## 00-02. 기본 타입스크립트 세팅하기

tsconfig 설정

```json
// tsconfig.json
{
  "compilerOtpions":{
    "strict":true,
    "lib": [
      "es5",
      "es2015",
      "es2016",
      "es2017",
      "es2018",
      "es2019",
      "es2020",
      "dom"
    ],
    "jsx": "react"
  }
}
```



webpack 설정

```js
// webpack.config.js
mode: 'development',// production
  devetool: 'eval', // production인 경우 hidden-source-map
  resolve:{
    extensions: ['jsx', 'js', 'tsx', 'ts']
  },

  entry: {
    app: './client' // client.tsx로 app.js를 만들 것이다.
  },
  module: {
    rules: [{
      test: /\.tsx?$/, 
      loader: 'ts-loader'
    }]
  },
  plugins: [

  ],
  output: {
    filename: '[name].js',
    path: path.join(__dirname, 'dist'),
  }
```

`npx webpack`하면, client.ts를 통해서 dist폴더안에 app.js가 생길 것이다.

정리

ts나 tsx는 브라우저에서 실행이 안되기 때문에, html에서 실행할땐 dist의 app.js를 실행

```html
// index.html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>구구단</title>
</head>
<body>
  <div id="root">
    <script src="./dist/app.js"></script>
  </div>
</body>
</html>
```

client.jsx

```jsx
// client.jsx
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import GuGuDan from './GuGudan';

ReactDOM.render(<GuGuDan />)
```

react와 react-dom은 export default가 없어 `* as`를 사용하지만, GuGuDan은 export default할 거기 때문에 그냥 GuGuDan으로 임포트 작성.



## 00-03. 이벤트 핸들러, useRef타이핑

GuGuDan작성

```jsx
import * as React from 'react';
import {useState, useRef} from 'react';
// <>는 React.Fragment
const GuGuDan = () =>{
  const [first, setFirst] = useState(Math.ceil(Math.random()*9));
  const [second, setSecond] = useState(Math.ceil(Math.random()*9));
  const [value, setValue] = useState('');
  const [result, setResult] = useState('');

  const inputEl = useRef(null);

  const onSubmitForm = (e) => {
    e.preventDefault();
    const input = inputEl.current;
    // 정답 시 초기화
    if(parseInt(value)===first*second){
      setResult('정답');
      setFirst(Math.ceil(Math.random()*9));
      setSecond(Math.ceil(Math.random()*9));
      setValue('')
      input.focus();
    }else{
      setResult('땡');
      setValue('')
      input.focus();
    }
  }

  return (
    <>
      <div>{first} 곱하기 {second}는?</div>
      <form onSubmit={onSubmitForm}>
        <input
          ref={inputEl}
          type="number"
          value={value}
          onChange={(e)=>setValue(e.target.value)}
        />
      </form>
    </>
  )
}

export default GuGuDan;
```

import를 추가하는 이유는 바벨이나 타입스크립트가 변환할때 `<>`가 undefined가 되기 때문에 React를 임포트해주어야한다.



위처럼 작성하면 `onSubmit에서 e`와`input`에서 에러가 나고 있을 것이다.

먼저, 마우스를 올려보면 onChange와 같이쓴 e는 ChangeEvent로 잘 추론되고있지만, 함수의 e는 정확히 추론되지 않아서 그렇다.

```tsx
const onSubmitForm = (e: React.FormEvent<HTMLFormElement>) => {...}
```

이렇게 타입을 작성해주면 된다.

❗ 같이쓰면 타입 추론이 잘 되지만, 대부분의 경우 useCallback을 사용해야해서 분리해서 사용할텐데 그경우 타입을 선언 해주어야 한다.



그 다음 input부분은 초기값을 null로 해놔서 null로 추론이 된다.

useRef에 제너릭 타입을 선언해주어 고칠 수 있다.

```tsx
const inputEl = useRef<HTMLInputElement>(null);
...
const input = inputEl.current;
...
input!.focus();
```

❗ `!`는 input값이 확실하게 있다는 100% 확신이 있을 때 사용해야한다. 따라서 확신이 없다면 if문으로 체크 해서 사용.

```tsx
if(input) input.focus();
```



`npm run dev`로 확인.





## 00-04. Class State 타이핑

```tsx
import * as React from "react";

class GuGuDan extends React.Component {
  state = {
    first: Math.ceil(Math.random() * 9),
    second: Math.ceil(Math.random() * 9),
    value: "",
    result: "",
  };

  onSubmitForm = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const { value, first, second, result } = this.state;

    // 정답 시 초기화
    if (parseInt(value) === first * second) {
      this.setState((prevState) => {
        return {
          result: "정답: " + prevState.value,
          first: Math.ceil(Math.random() * 9),
          second: Math.ceil(Math.random() * 9),
          value: "",
        };
      });

      this.input.focus();
    } else {
      this.setState((prevState) => {
        return {
          result: "땡: " + '',
          value: "",
        };
      });
      this.input.focus();
    }
  };

  onChange = (e) => {
    this.setState({ value: e.target.value });
  };
  input;
  onRefInput = (c) => {
    this.input = c;
  };
  return() {
    <>
      <div>
        {this.state.first} 곱하기 {this.state.second}는?
      </div>
      <form onSubmit={this.onSubmitForm}>
        <input
          ref={this.onRefInput}
          type="number"
          value={this.state.value}
          onChange={this.onChange}
        />
      </form>
      <div>{this.state.result}</div>
    </>;
  }
}

export default GuGuDan;

```

함수를 따로 분리를 했다면 해당 메서드에서 타입 추론이 일어나지 않을 것이다.



그다음 init과 prevstate부분을 고치자.

```tsx
import * as React from "react";

interface InitState{
  first: number,
  second: number,
  value: string,
  result: string,
}

class GuGuDan extends React.Component<InitState> {
 ...

  onSubmitForm = (e: React.FormEvent<HTMLFormElement>) => {
...
    // 정답 시 초기화
    if (parseInt(value) === first * second) {
      this.setState((prevState: InitState) => {
        return {
          result: "정답: " + prevState.value,
          first: Math.ceil(Math.random() * 9),
          second: Math.ceil(Math.random() * 9),
          value: "",
        };
      });
      if(this.input) this.input.focus();
    } else {
      this.setState((prevState) => {
        return {
          result: "땡: " + '',
          value: "",
        };
      });
      if(this.input) this.input.focus();
    }
  };
....
}

export default GuGuDan;

```

state에 대한 interface를 만들어 추가해주면된다.

Component에 제네릭 타입으로 줄 수 있다. 첫번째는 props, 두번째는 state타입.





## 00-05. useCallback 타이핑

끝말잇기도 빠르게 해보자.

